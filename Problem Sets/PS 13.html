<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<style>
body { font: 14px Trebuchet MS; }
span.star {color: red; font: bold 18px Verdana, Arial, Helvetica, sans-serif;}
tt, pre { color: blue; }
</style>
<title>CS112 Spring 2017: Problem Set 13 Solution</title>
</head><body>
<center>
<h1>Problem Set 13 - Solution</h1>
<h2>Dijkstra's Algorithm, Mergesort</h2>
</center>
<hr>
<ol>
<li>Suppose you are given this undirected graph in which the vertices are
towns, and the edges are toll roads between them. The weight of an edge
is the dollar amount of toll. 

<p style="margin-left:100px;"><img src="graph1.png">

</p><p>Use Dijsktra's shortest paths algorithm to
determine the minimum toll route from <tt>A</tt> to all other cities. 

</p>

<ul>

<li>Show each step
of the algorithm in tabular form. Here's the table after the initial step:

<pre>    Done   D[B]    D[C]    D[D]    D[E]    D[F]    D[G]    D[H]    D[I]
   ---------------------------------------------------------------------
     A     4,A      &#8734;       &#8734;       &#8734;       &#8734;       &#8734;     8,A       &#8734;
</pre>
Note that along with the distance, the "previous" vertex is also shown.

<p></p></li><li>Draw the shortest path tree induced on the graph.
</li></ul>

<p><b>SOLUTION</b>

<pre>    Done   D[B]    D[C]    D[D]    D[E]    D[F]    D[G]    D[H]    D[I]
   ---------------------------------------------------------------------
     A     4,A       &#8734;      &#8734;       &#8734;       &#8734;        &#8734;     8,A       &#8734;
     B            12,B      &#8734;       &#8734;       &#8734;        &#8734;     8,A       &#8734;

     H            12,B      &#8734;       &#8734;       &#8734;       9,H            15,H
     G            12,B      &#8734;       &#8734;       11,G                   15,H
     F            12,B     25,F    21,F                          15,H
     C                     19,C    21,F                          14,C
     I                     19,C    21,F
     D                             21,F
     E
</pre>
Note that along with the distance, the "previous" vertex is also shown.

<p>The shortest path tree induced on the graph:
<p><img src="spt.png">

<hr>
<li>Trace the mergesort algorithm on the following list:
<pre>     3, 26, 67, 25, 9, -6, 43, 82, 10, 54

</pre>
Show the resulting recursion tree, with the to-be-sorted original and
sub-lists at each node, and the number comparions for each merge.
(Assume that if there is an odd number of entries in an array,
the left part has one more entry than the right after the
split.)
<p>
<b>SOLUTION</b>
<p>The original and sorted result indicated above and below:
<pre>
                              <font color="red">  -6,3,9,10,25,24,43,54,67,84  #c9</font>
             3,  26,  67, 25,  9, -6, 43, 82, 10, 54  
                     /                       \
                    /                         \
                   /  <font color="red">3,9,25,26,67  #c3</font>        \  <font color="red">-6,10,43,54,82  #c4</font>
           3, 26, 67, 25, 9             -6, 43, 82, 10, 54
            /          \                  /             \
           /            \                /               \
          / <font color="red">3,26,67 #c2</font>  \ <font color="red">9,25 #c1</font>     / <font color="red">-6,43,82 #c2</font>    \ <font color="red">10,54  #c1</font>
      3, 26, 67        25, 9         -6, 43, 82          10, 54
     /        \         /   \        /         \         /     \
    /<font color="red">3,26 #c1</font>  \ <font color="red">67</font>    / <font color="red">9</font>   \ <font color="red">25</font>   /<font color="red">-6,43 #c1</font>  \ <font color="red">82</font>    / <font color="red">10</font>    \ <font color="red">54</font> 
  3,26         67     9      25  -6,43           82    10       54 
  /  \                            /  \                    
 /<font color="red">3</font>   \ <font color="red">6</font>                        / <font color="red">-6</font> \<font color="red">43</font>
3     26                        -6    43                      
</pre>
<hr>
<li>Mergesort works well on linked lists since it doesn't need any extra
space. Given the following linked list node class:
<pre>
    public class LLNode&lt;T extends Comparable&lt;T>>  {
       public T info;
       public LLNode&lt;T> next;
       ...
    }

</pre>
complete the following method to "split" the linked list in half:
<pre>
    // splits the given list in half such that the return value is 
    // a reference to the first node of the second half. Also, the 
    // "next" field of the last node in the first half is set to null.
    static &lt;T extends Comparable&lt;T> LLNode&lt;T> split(LLNode&lt;T> list) {
       // COMPLETE THIS METHOD
    }
</pre>
<b>SOLUTION</b>
<pre>
    static &lt;T extends Comparable&lt;T> LLNode&lt;T> split(LLNode&lt;T> list) {
       if (list == null) return null;

       int size=0;
       LLNode&lt;T> ptr;
       for (ptr=list; ptr != null; ptr = ptr.next) {
           size++;
       }
       size = (size+1)/2; ptr=list;
       while (size > 1) {
          ptr = ptr.next;
          size--;
       }
       LLNode&lt;T> second = ptr.next;
       ptr.next = null;
       return second;
   }
</pre>
<hr>
<li>In Problem Set 3, #6, you saw how to merge two sorted linked lists of
integers, into a single sorted list without duplicates. Here is
the header of a modified version of that method, that merges 
lists of <tt>Comparable</tt> objects (not just <tt>int</tt>s), while
preserving duplicates, if any. Complete this method
using recursion. Your method should
recycle the nodes in the original lists (no new
nodes should be created).
<pre>
    // merge the lists l1 and l2 into a single linked list, whose
    // first node is referenced by the return value - no additional
    // linked list nodes are used
    static &lt;T extends Comparable&lt;T>> LLNode&lt;T&gt; merge(LLNode&lt;T&gt; l1, LLNode&lt;T&gt; l2) {
       // COMPLETE METHOD USING RECURSION, NO NEW NODES TO BE CREATED
    }
</pre>
Using this merge solution, and the solution to the split in the previous
problem, complete the mergesort implementation:
<pre>
    // Sorts the input linked list using mergesort, and returns the front of
    // the sorted linked list. DOES NOT CREATE ANY ADDITIONAL NODES.
    public static &lt;T extends Comparable&lt;T> 
    LLNode&lt;T> mergesort(LLNode&lt;T> list) {
       // COMPLETE THIS METHOD
    }
</pre>
<p><b>SOLUTION</b>
<pre>
    // merge the lists l1 and l2 into a single linked list, whose
    // first node is referenced by the return value - no additional
    // linked list nodes are used
    static &lt;T extends Comparable&lt;T>> LLNode&lt;T&gt; merge(LLNode&lt;T&gt; l1, LLNode&lt;T&gt; l2) {
       // COMPLETE METHOD USING RECURSION, NO NEW NODES TO BE CREATED
       if (l1 == null) { return l2; }
       if (l2 == null) { return l1; }
       if (l1.info.compareTo(l2.info) < 0) {
          l1.next = merge(l1.next, l2);
          return l1;
       } else {
          l2.next = merge(l1, l2.next);
          return l2;
       }
    }
</pre>
<pre>
    public static &lt;T extends Comparable&lt;T> 
    LLNode&lt;T> mergesort(LLNode&lt;T> list) {
        // empty or single node list
        if (list == null || list.next == null) {
           return list;
        }
        // split
        LLNode&lt;T> second = split(list);

        // recursive calls
        list = mergesort(list);
        second = mergesort(second);

        // merge
        return merge(first, second);
    }
</pre>
</ol>
</body></html>
