<html><head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<style>
body { font: 14px Trebuchet MS; }
span.star {color: red; font: bold 18px Verdana, Arial, Helvetica, sans-serif;}
pre { color: blue; }
</style>
<title>CS112 Spring 2017: Problem Set 14 Solution</title>
</head><body>
<center>
<h1>Problem Set 14 - Solution</h1>
<h2>Sorting/Dijkstra's Algorithm Analysis Review</h2>
</center>
<hr>
<ol>
<li> Trace the quicksort algorithm 
on the following array:
<pre>    
   3, 26, 67, 25, 9, -6, 43, 82, 10, 54
</pre>
Use the median of the first, middle, and
last entries as the pivot to split a subarray. (If a subarray has fewer than
3 entries, use the first as the pivot.) Show the quicksort tree and
the number of comparisons at each split.
<b>SOLUTION</b><br>
<pre>
         [3  26  67  25  9  -6  43  82  10  54]   median(3,9,54)=9, swap(9,3)
                         split
                          | pivot=9, # of comp = 9
                          V
         [3  -6]          9         [25  67  26  43  82  10  54]
           split                               split
             | piv=3,#c = 1                     | piv=43,#c = 6
             V                                  V
       [-6]  3                   [25  10  26]   43     [82  67  54]
                                     split                  split
                                       | piv=25,#c=2         | piv=67,#c=2
                                       V                     V
                                 [10]  25   [26]       [54]  67  [82]

</pre>
Total number of comparisons = 20
<hr>
<li>Given the following input array:
<pre>    
   3, 26, 67, 25, 9, -6, 43, 82, 10, 54
</pre>
<ol>
<li>Trace the linear time build-heap algorithm on this array, to 
build a max-heap. How many comparisons did it take to
build the heap?
</li><li>Starting with this max-heap, show how the array is then sorted
by repeatedly moving the maximum entry to the end and applying sift-down to
restore the (remaining) heap. How many comparisons did it take to
sort the heap?
</li></ol>
<p>
<b>SOLUTION</b>
</p>
<ol>
<li>
<pre>             Array                                       Sift Down    Comparisons
    ---------------------------------------------        ---------    -----------
    3   26   67   25   9   -6   43   82   10   54            9           1

    3   26   67   25   54   -6   43   82   10   9           25           2

    3   26   67   82   54   -6   43   25   10   9           67           2

    3   26   67   82   54   -6   43   25   10   9           26           4

    3   82   67   26   54   -6   43   25   10   9            3           5

    82   54   67   26   9   -6   43   25   10   3           done

</pre>

</li><li>
<pre>
             Array                                       Sift Down    Comparisons
    ---------------------------------------------        ---------    -----------
    82   54   67   26   9   -6   43   25   10   3           
                    swap(82,3)
    3   54   67   26   9   -6   43   25   10   82            3            4    


    67   54   43   26   9   -6   3   25   10   82           
                    swap(67,10)
    10   54   43   26   9   -6   3   25   67   82           10            6


    54   26   43   25   9   -6   3   10   67   82           
                    swap(54,10)
    10   26   43   25   9   -6   3   54   67   82           10            4


    43   26   10   25   9   -6   3   54   67   82           
                    swap(43,3)
    3   26   10   25   9   -6   43   54   67   82            3            4


    26   25   10   3   9   -6   43   54   67   82            
                    swap(26,-6)
    -6   25   10   3   9   26   43   54   67   82           -6            4


    25   9   10   3   -6   26   43   54   67   82           
                    swap(25,-6)
    -6   9   10   3   25   26   43   54   67   82           -6            2


    10   9   -6   3   25   26   43   54   67   82           
                    swap(10,3)
    3   9   -6   10   25   26   43   54   67   82            3            2


    9   3   -6   10   25   26   43   54   67   82            
                    swap(9,-6)
    -6   3   9   10   25   26   43   54   67   82           -6            1


    3   -6   9   10   25   26   43   54   67   82          
                    swap(3,-6)
    -6   3   9   10   25   26   43   54   67   82          done


</pre>
</ol>
<hr>
<li>
<p>A <em>stable</em> sorting algorithm is one which preserves the order of duplicate elements
when sorted. For instance, suppose the following pairs of values are sorted on the
<b>first</b> value in the pair:
<pre>
    (3,sun)  (2,mars)  (4,moon)  (3,venus)
</pre>
then the output of a stable sorting algorithm would be:
<pre>
    (2,mars)  (3,sun)  (3,venus)  (4,moon)
</pre>
Notice that <tt>(3,sun)</tt> comes before <tt>(3,venus)</tt>, preserving 
the order of the input for elements that have the same sortable value of 
<tt>3</tt>, hence <em>stable</em>.

<p>However, if the output is this:
<pre>
    (2,mars)  (3,venus)  (3,sun)  (4,moon)
</pre>
then the sorting algorithm is not stable since it does not preserve the input 
order of <tt>(3,sun)</tt> before <tt>(3,venus)</tt>.

<p>For each of insertion sort, mergesort, and quicksort, tell whether the 
algorithm is stable or not.
<p><b>SOLUTION</b>
<ul>
<li>Insertion sort is a stable sort. 
<li>Mergesort is a stable sort.
<li>Quicksort is not a stable sort.
</ul>
<hr>
<font color="brown">
<p>Problems 4-8 below are on analyzing the worst case big O
running time of Dijkstra's shortest paths algorithm. Assume the graph has
<em>n</em> vertices, and <em>e</em> edges with positive weights. And,
except for problem #8 the graph is stored in adjacency linked lists.

<p>The first step in the analysis is to identify the primary activities that
are to be counted towards the running time. These are:
<ul>
<li>(A)dding a vertex to the fringe
<li>(P)icking the minimum distance vertex from the fringe
<li>(C)hecking the neighbors of a vertex, for possible distance update
<li>(U)pdating (lowering) the distance of a vertex that is in the fringe
</ul>

<p>We will ignore the time to set the initial distance of a vertex. The reason is
it takes unit time to set the distance in the distance array, but is done
done as a part of the (A)dding a vertex to the fringe, which will take at least unit 
time. So as far as big O is concerned, determining the time to (A)dd fringe
vertices will also account for distance initialization.

<p>We will also ignore the time to set the previous vertex. Using a similar
argument as above, it takes unit time to set the previous vertex in the previous
array. But this is done as a part of (A)dding a vertex to the fringe, or (U)pdating
the distance of a vertex, and the (A)dd and (U)pdate will take at least unit time
themselves. So accounting for the (A)dd and (U)pdate times will suffice as 
far as the big O is concerned.

<p>The fringe is the variable part as far the data structures are concerned
(since distance and previous vertex are recorded in arrays), and the worst
case depends on exactly how the fringe is implemented. You will compute
the running times for different versions of the fringe in problems 5-7.

</font>
<hr>

<li>What is the total running time, through the entire run of the algorithm,
for (C)hecking the neighbors of each vertex for possible distance update? Does this 
depend on the fringe?

<p><b>SOLUTION</b>
<p>The running time for (C)hecking the neighbors of each vertex does not depend
on the fringe, since the neighbors and edge weights are obtained from the adjacency linked 
lists, and the current distance is obtained from the distance array. 

<p>The total
number of neighbors of all vertices is <em>e</em>, if the graph
is directed, and <em>2e</em>, if the graph is undirected. Each neighbor contributes one
unit of time toward the distance check, so we get <em>O(e)</em> for 
the total running time.
<hr>
<li>If the fringe was implemented as an unordered linked list (not arranged in any
specific order of distances), what would be the big O worst case running time of
each of the A, P, and U components of the algorithm, through the entire run from
start to end? What would be the total worst case big O running time of the algorithm?

<p><b>SOLUTION</b>

<p>Here are the times for the individual components:
<ul>
<li>A: Initially adding <em>n-1</em> vertices to the fringe.<br>
Starting with an empty fringe, add one vertex at a time on fringes of increasing size.
Since fringe is an unordered linked list, adds can be done at the front of the linked
list in O(1) time each, so the total time is <em>(n-1)</em>*O(1), which is <em>O(n)</em>

<li>P: Picking min dist vertex from the fringe.<br>
Starting with a fringe of size <em>n-1</em>, pick vertices from fringes of decreasing size.
Identifying the minimum distance vertex in an unordered linked list of size <em>k</em>
will take <em>(k-1)</em> time units. So the series of minimum picks will add up as
follows:
<pre>   
  (n-2) + (n-3) + ... + 2 + 1 = (n-1)*(n-2)/2
</pre>
which is <em>O(n<sup>2</sup>)</em>
<li>(U): Updating distance of vertex in fringe.<br>
The updates are done in the distance array, the structure of the fringe itself is
not relevant. Each update can be done in O(1) time. In the worst case, every
neighbor distance check results in an update. Since there are <em>O(e)</em> neighbor
distance checks in all, this gives a total time of <em>O(e)</em>
</ul>
<p>Adding these times, and factoring in the time of <em>O(e)</em> for the (C) 
component worked out in the previous problem, gives us a total time of:
<pre>
     O(n) + O(n<sup>2</sup>) + O(e) + O(e) = O(n<sup>2</sup>)
</pre>
<hr>
<li>Repeat the analysis for a fringe implemented as a linked list maintained
in ascending order of distances.

<p><b>SOLUTION</b>
<p>Here are the times for the individual components:
<ul>
<li>A: Initially adding <em>n-1</em> vertices to the fringe.<br>
Starting with an empty fringe, add one vertex at a time on fringes of increasing size.
Since fringe is an ordered linked list, each add needs to first find the correct spot,
which will take <em>(k-1)</em> comparisons in the worst case for a linked list of 
length <em>k</em>.
So the total time is:
<pre>   
  0 + 1 + 2 + ... + (n-3) + (n-2) = (n-1)*(n-2)/2 = O(n<sup>2</sup>)
</pre>
<li>P: Picking min dist vertex from the fringe.<br>
Starting with a fringe of size <em>n-1</em>, pick vertices from fringes of decreasing size.
Since the linked list is arranged in ascending order of distances, the minimum distance
vertex is the first item, and can be accessed in unit time. So the total time
is <em>O(n)</em>
<li>(U): Updating distance of vertex in fringe.<br>
While the actual updates are done in the distance array, because the fringe is
maintained in ascending order of distances, an update would in general require
a repositioning of the vertex in the linked list. 

<p>The new distance would need
to be compared with the distance of the vertex before it in the linked list.
If the new distance is less, then another comparison would need to made with
the vertex two spots before this vertex, etc. In the worst case, this sequence
of comparisons would go all the way to the front of the list, so that if the
list is of length <em>k</em>, then <em>(k-1)</em> comparisons would need to be made
to move the last item all the way to the front.

<p>For the worst case for all updates, we assume that all <em>e</em> updates are
done on the maximum possible fringe size, which is <em>n-2</em> (updates are
done after picking the first vertex out of the initial fringe of size (n-1),
which leaves (n-2) in the fringe).

<p>The time for
a single update on this fringe size would be O(<em>e</em>), as outlined in
the previous paragraph, so time for all <em>e</em> updates would be O(<em>en</em>)
</ul>
<p>Adding these times, and factoring in the time of <em>O(e)</em> for the (C) 
component, gives us a total time of:
<pre>
     O(n<sup>2</sup>) + O(n) + O(en) + O(e) = O(n<sup>2</sup>+en)
</pre>

<hr>
<li>Repeat the analysis for a fringe implemented as a min-heap that supports
inserts, deletes, and priority updates in <em>O(log n)</em> time.

<p><b>SOLUTION</b>
<p>Here are the times for the individual components:
<ul>
<li>A: Initially adding <em>n-1</em> vertices to the fringe.<br>
Starting with an empty fringe, add one vertex at a time on fringes of increasing size.
Since the fringe is a min-heap, adding (which includes sifting up) in a heap of
size <em>k</em> would take <em>O(log k)</em> time. So the total time is:
<pre>   log 1 + log 2 + log 3 ... + log (n-1) = log (n-1)! = O(nlogn)
</pre>

<li>P: Picking min dist vertex from the fringe.<br>
Starting with a fringe of size <em>n-1</em>, pick vertices from fringes of decreasing size.
Again, since deleting from a heap of size <em>k</em> would take <em>O(log k)</em> time,
the total time is:
<pre>log (n-2) + log(n-3) ... + log 2 + log 1 = log (n-1)! = O(nlogn)
</pre>
(The first term is log(n-2) because sift down is done after deleting the top of
the heap, on the remaining (n-2) items.)

<p><li>U: Updating distance of vertex in fringe.<br>
Updating the priority (which here means decreasing the distance) of an item
in a heap of size <em>k</em> takes <em>O(log k)</em> time.
For the worst case for all updates, we assume that all <em>e</em> updates are
done on the maximum possible fringe size, which is <em>n-1</em>,
so time for all <em>e</em> updates would be O(<em>elogn</em>)
</ul>
The total running time, adding the time for all components, and bringing in the time
for (C) is:
<pre>
    O(nlogn) + O(nlogn) + O(elogn) + O(e) = O((n+e)logn)
</pre>

<hr>
<li>Repeat the analysis for a fringe implemented as a min-heap that supports
inserts, deletes, and priority updates in <em>O(log n)</em> time, 
for a graph stored in an adjacency <em>matrix</em> format instead of adjacency
linked lists.

<p><b>SOLUTION</b>

<p>In #7 above, we analyzed the running time for an updatable-heap based fringe, and it
turned out to be O((<em>n+e</em>)<em>logn</em>). However this assumed that the graph
was stored in adjacency linked format, which resulted in an O(<em>e</em>) running
time for the (C) component. But if the graph is stored in an adjacency matrix, the
running time of the (C) component would change to O(<em>n<sup>2</sup></sup></em>). All other
components would have the same running time since they all depend only on the
fringe. 

<p>Since the (C) component was not the dominant one in the original analysis, we 
can simply replace the old running time of (C) with O(<em>n<sup>2</sup></sup></em>), 
which changes the running time to:
<pre>    O(nlogn) + O(elogn) + O(n<sup>2</sup></sup>) = O(n<sup>2</sup></sup>+elogn) 
</pre>
(Since <em>n</em><sup>2</sup> is of a higher order than <em>nlogn</em>, the 
<em>nlogn</em> term is taken out)
</ol>


</ol>
