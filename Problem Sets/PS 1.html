
<!-- saved from url=(0085)https://www.cs.rutgers.edu/courses/112/classes/fall_2016_venugopal/probs/ps1_sol.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<style>
span.star {color: red; font: bold 18px Verdana, Arial, Helvetica,
sans-serif;}
body { font: 14px Trebuchet MS; }
pre, tt { color: blue;}
</style>
<title>CS112 Fall 2016: Problem Set 1</title>
</head><body>
<center>
<h1>Problem Set 1</h1>
<h2>Big O</h2>
</center>
<hr>
<ol>
<li>Exercise 3.7 of the textbook.
<p>An algorithm prints the following pattern:
</p><pre>*
* *
* * *
* * * *
* * * * *

</pre>
<ol style="list-style-type: lower-alpha;">
<li>What are the basic operations performed by the algorithm that you would
count towards its running time?
</li><li>Count the number of these basic operations for the specific output shown
above.
</li><li>The number of lines printed in the preceding pattern is 5. Assume that the
algorithm can extend this pattern for any number of lines (line number <em>i</em>
has <em>i</em> stars). If the number of lines, <em>n</em> is the input to the
algorithm, how many basic operations are performed as a function of <em>n</em>?
</li><li>Write your answer to the above question as a big <em>O</em> order.
</li></ol>
<p><b>SOLUTION</b>
</p><ol style="list-style-type: lower-alpha;">
<li>Printing a star, printing a blank space, printing a newline
</li><li>15 print stars, 10 print blank spaces, 5 print newlines
</li><li><em>n*(n+1)/2</em> print stars, <em>n*(n-1)/2</em> print spaces,
<em>n</em> print newlines
</li><li><em>O(n</em><sup>2</sup><em>)</em>
</li></ol>
<hr>
</li><li> Exercise E3.10, page 117 of the textbook.
            <p>A spreadsheet keeps track of student scores on all the exams in a course.&nbsp;
            Each row of the spreadsheet corresponds to one student, and each column
            in a row corresponds to his/her score on one of the exams.&nbsp; There
            are <i>r</i> students and <i>c</i> exams, so the spreadsheet has <i>r</i>
            rows and <i>c</i> columns.</p>
            <p>Consider an algorithm that computes the total score on all exams
            for each student, and the average class score on each exam.&nbsp;
            You need to analyze the running time of this algorithm.</p>
            <ol style="list-style-type: lower-alpha;">
                <li>What are the basic operations you would count toward the
                running time?</li>
                <li>What is the worst-case running time as a total count (not
                big <i>O</i>) of these basic operations?</li>
                <li>What is the big <i>O</i> running time?</li>
                <li>Is your algorithm linear, quadratic, or some other order?</li>
            </ol>

<p>
<b>SOLUTION</b>
            </p><ol style="list-style-type: lower-alpha;">
<li> Basic operations are addition and division.
</li><li>Each student total (which starts at zero) will be added to 
<em>c</em> times. Since there are <em>r</em> student totals, there are
<em>r*c</em> additions for the totals.

<p>Each exam average will
added to <em>r</em> times. Since there are <em>c</em> exams, this gives
another <em>c*r</em> additions.

</p><p>Each exam average will be divided exactly once 
by the number of students, <em>c</em>. So, <em>c</em> divisions.
</p></li>
<li> O(<em>rc</em>) 
</li><li> LINEAR (Note: The Big O looks like a quadratic value, but the INPUT SIZE
is <em>rc</em>, and the running time is linearly proportional to the input size.)
</li></ol>
<hr>
</li><li>Exercise 3.14, pg 118 of the textbook
<p>A card game program keeps a deck of cards in an array. Give an algorithm to
"unshuffle" the deck so that all the cards of a suit are grouped together, and
within each suit, the cards are in ascending order or rank--consider the ace as
the lowest ranked card. Since there are only 52 cards, space is not an issue so
you can use extra space if needed. The only constraint is that your algorithm be
as fast as possible. 

</p><p>What is the worst case big O running time of your algorithm? What are the basic
operations you used in your analysis? Is the average big O running time different
from the worst case?
</p><p>
<b>SOLUTION</b>
</p><p>Allocate four new arrays, each of length 13, one for each suit. Go through the
original deck from front to end, and slot each card in its appropriate position in
the suit array to which it belongs. So for example the queen of hearts will go
to index position 11 in the hearts array. Note that since the indexes of the arrays
are from 0 through 12, the array position of a card will be one less than its face
value. (Queen's face value is 12, so its array position will be 11.) 

</p><p><font color="red">The big O running time is O(1)!!</font>

</p><p>The basic operations are (a) looking up 
a card in the deck array, and (b) writing it into a suit array. Each of these takes
unit time. (Writing takes unit time because the suit array is directly
indexed with the card's face value.) Since there are 52 look ups and 52 writes, the
total number of basic operations, and therefore the total units of time, is 104.
This is a constant, so the big O time is O(1).

</p><p>Pay attention to this result, because what it says is that no matter how many
actual operations you perform, because the input size is always the same, 52, the
number of operations does not vary. Hence O(1).
</p><hr>
</li><li><span class="star">*</span>&nbsp;Exercise E3.11, page 118 of the
textbook.
            <p>Two people compare their favorite playlists for matching songs.&nbsp;
            The first playlist has <i>n</i> songs, and the second has <i>m</i>.&nbsp;

            Each is stored in an array, in no particular order.&nbsp; 
</p><ol>
<li>Describe an algorithm to find the common songs in these lists (intersection),
WITHOUT sorting either list.<p></p>
            <ol style="list-style-type: lower-alpha;">
                <li>What is the worst-case big <i>O</i> running time of your algorithm?&nbsp;
                Make sure to state the basic operations used in your analysis of
                running time.</li>
                <li>What is the best-case big <i>O</i> running time of your
                algorithm?&nbsp; Explain clearly, including all book-keeping
                needed to achieve this best case.</li>
            </ol>
<p></p></li><li>Now suppose you could sort either or both arrays (as part of your algorithm).
Repeat the worst-case and best-case analysis for the big <i>O</i> running time.
(The running time must include the time to sort.)
</li></ol>
<p>
<b>SOLUTION</b>
</p><ol>
<li>
Algorithm: For each song in the first playlist, do a linear search in the second
and if a match is found, add it to the output list.

<p></p><p>Basic operation is a comparison between a pair of songs.
</p><ol>
<li>In the worst case, there are no common songs. Every song
in the first list gets compared with every song in the second, for
a total of <em>n*m</em> comparisons, and therefore, O(<em>n*m</em>)
</li><li>In the best case, there is a maximum number of common songs, which
would be min(<em>m</em>,<em>n</em>) (number of common songs cannot exceed
the length of the smaller list). Also, the least number of comparisons is
made to find a match. Again, doing a linear search for each song in the
<em>n</em> list against the songs in the <em>m</em> list, the first song 
in the <em>n</em> list matches the first song in the <em>m</em> list (1 comparison), 
the second song 
in the <em>n</em> list matches the second song in the <em>m</em> list (2 comparisons), 
and so on. This gives a total of:
<pre>    1+2+3+...+min(m,n) 
</pre>
comparisons, which is O(min(<em>m</em>,<em>n</em>)<sup>2</sup>)
</li></ol>
</li><li>Use mergesort to sort each array. Then use the sorted lists merge algorithm
to compare songs pair-wise and only keeping in the output the pairs that match.
<ol>
<li>Worst case: O(mlog m) + O(nlog n) + O(m+n) = O(mlog m + nlog n)
</li><li>Best case: O(mlog m) + O(nlog n) + O(min(m,n)) = O(mlog m + nlog n)
</li></ol>
</li></ol>
<hr>
</li><li><span class="star">**</span> Exercise E3.15, page 118 of the
textbook.
                <p>There is a highway with <i>n</i> exists numbered 0 to <i>n</i> - 1.&nbsp;
                You are given a list of the distances between them.&nbsp; For
                instance:</p>
<pre>Exits:     1   2   3   4   5   6
Distances: 5   3   4   2   8   6</pre>
            <p>The distance from the start of the highway to exit <code>1</code> 
            is <code>5</code>, from exit <code>1</code> to <code>2</code> is 
            <code>3</code>, and so on.</p>
            <p>You have to devise an algorithm that would calculate the distance
            between any two exits.&nbsp; Imagine that this distance function is
            called millions of times by applications that need this information,
            so you need to make your algorithm as fast as possible.</p>
            <p>Describe your algorithm.&nbsp; What is the worst-case big <i>O</i>
            running time?&nbsp; Make sure to state all the parameters you use in
            the analysis and relate them to the algorithm.</p>

<p>
<b>SOLUTION</b>
</p><p>As the function that calculates the distance between any two exits is going
to be called millions of times, it should be as fast as possible, ideally 
<em>O(1)</em> We can achieve this speed by
creating an array, <tt>S</tt> of distances of each exit from the start of the highway.
Assume that the original distances between exits (as in the example
given in the problem) are in an array <tt>D</tt>

</p><pre>   // copy distances between pairs of exits from D to S
   for (i=0; i &lt; n; i++) {
       S[i] = D[i];
   }
   // compute distance ("sum") from start for each exit
   for (i=1; i &lt; n; i++) {
       S[i] = S[i-1] + S[i];
   }

   D: 5  3  4  2  8  6
   S: 5  8 12 14 22 28

</pre>

Creating the array takes linear time (<em>O(n)</em>) but
using it will take constant time (<em>O(1)</em>). 


Once <tt>S</tt> is created, finding the distance
from exit <tt>i</tt> to exit <tt>j</tt> is a simple matter of computing
<tt>S[j] - S[i]</tt>.


  <p></p>

<p><b>Running time Analysis</b>

</p><p>
</p><ul><li>The basic operation for creating the <tt>S</tt> array is calculating
the distance of each exit from the start of highway. It takes O(1) time for each
exit and there are <em>n</em> exits. Therefore, it takes <em>O(n)</em> time.
</li><li>The basic operation for finding the distance between two exits after we
have the <tt>S</tt> array is a subtraction of two distance, both of which are
obtained in constant time. So, <em>O(1)</em> time. 
</li></ul>
</li></ol>
<hr>




</body></html>