
<html>
<head>
<style>
span.star {color: red; font: bold 18px Verdana, Arial, Helvetica,
sans-serif;}
body { font: 14px Trebuchet MS; }
pre, tt { color: blue;}
</style>
<title>CS112 Spring 2017: Problem Set 6 Solution</title>
</head><body>
<center>
<h1>Problem Set 6 - Solution</h1>
<h2>Binary Search Tree (BST)</h2>
</center>
<hr>
<ol>
<li>Given the following sequence of integers:
<pre>    10, 17, 3, 90, 22, 7, 40, 15
</pre>
<ol>
<li>Starting with an empty binary search tree, insert this sequence of integers one 
at a time into this tree. Show the final tree. Assume that the tree 
will not keep any duplicates. This means when a new item is attempted to be inserted, 
it will not be inserted if it already exists in the tree.
</li><li>How many item-to-item comparisons in all did it take to build this tree? (Assume 
one comparison for equality check, and another to branch left or right.)
</ol>
<p><b>SOLUTION</b>
<p>
Following is the final tree. 
<pre>
                         10            // 0 comparisons for 1st item
                      /       \
                     3        17       // 2 comparisons each for 3 and 17
                      \      /   \
                       7    15   90    // 4 comparisons each for 7, 15, and 90
                                 /
                                22     // 6 comparisons
                                  \
                                  40   // 8 comparisons 
</pre>
Total number of comparisons = 30
<hr>
<li>For the tree built in the above problem:
<ol>
<li>What is the worst case number of comparisons for a successful search in this tree?
For an unsuccessful (failed) search? (Assume one comparison for equality check, and 
another to branch left or right.)
<p><b>ANSWER</b>
<pre>
                         10            
                      /       \
                     3        17       
                    / \      /   \
                   F    7    15   90    
                       / \  / \   / \
                      F  F F  F 22   F    
                               /  \
                              F    40   
                                  /  \
                                 F    F
</pre>

Note: The 'F' nodes are not actual tree nodes - they are failure positions.
<ul> 
<li> <b>Successful search</b>: 9 comparisons. (search for 40)
<li> <b>Failed search</b>: 10 comparisons (search for 23 thru 39, or 41 
thru 89 - these will end up in one of the lowest level leaf
nodes marked 'F' in the tree above. 
</ul>

<p><li>What is the average case number of comparisons for a successful search in this 
tree? 
<p><b>ANSWER</b>
<p>Average case number of comparisons for successful search:
<pre>
                         10            // 1 comparison for match
                      /       \
                     3        17       // 3 comparisons each for 3 and 17
                      \      /   \
                       7    15   90    // 5 comparisons each for 7, 15, and 90
                                 /
                                22     // 7 comparisons
                                  \
                                  40   // 9 comparisons 
</pre>
Total number of comparisons = 1+2*3+3*5+7+9 = 38. Total number of successful
search positions = 8. Assuming equal probabilities of search for all
successful search positions, average number of comparisons = 38/8.
</li>

<p><li>From this tree, delete 17: find the node (y) that has the smallest
value in its right subtree, write y's value over 17, and delete y. How much work 
in all (locating 17, then
locating y , then deleting y) did it take to complete the
deletion? Assume the following (a) you are using two pointers to navigate 
down the tree, a tracking pointer, and a lagging pointer, (b) 
1 unit of work for an equality comparison between target
and tree item, one for
an inequality check to branch left or right,
and 1 unit of work for a pointer assignment.

<p><p><b>ANSWER</b>
<p>To delete 17, here is the work done:
<ul>
<li><b>Locating 17</b>: Number of comparisons is 3. Number of pointer assignments is 6:
to move two pointers (prev and ptr) down the
tree, with 2 initial assignments (prev=null, ptr=@10), 
then 2 assignments to move to 17 (prev=@10, ptr=@17)
</li><li><b>Locating y</b>: The smallest value in the 
right subtree of 17 is 22. Locating this
requires 4 more pointer assignments. (Move prev and ptr from 
17 to 90, then 90 and 22.)
</li><li><b>Overwriting 17 with 22</b>: Not counted since there is no comparison or
pointer assignment.
</li><li><b>Deleting y (22)</b>: One pointer assignment to set 
90's left child to @40.
</li></ul>
<p>So in all, comparisons=3, 
pointer assignments=6+4+1=11, for a total of 3+11=14 units of work total.
</ol>

<hr>
</li><li>Given the following BST node class:
<pre>    public class BSTNode&lt;T extends Comparable&lt;T&gt;&gt; {
        T data;
        BSTNode&lt;T&gt; left, right;
        public BSTNode(T data) {
            this.data = data;
            this.left = null;
            this.right = null;
        }
         public String toString() {
            return data.toString();
        }
   }
</pre>
Consider the following method to insert an item into a BST that does
not allow duplicate keys:
<pre>   public class BST&lt;T extends Comparable&lt;T&gt;&gt; {
        BSTNode&lt;T&gt; root;
        int size;
        ...
        public void insert(T target) 
        throws IllegalArgumentException {

                BSTNode<t> ptr=root, prev=null;
                int c=0;
                while (ptr != null) {
                        c = target.compareTo(ptr.data);
                        if (c == 0) {
                                throw new IllegalArgumentException("Duplicate key");
                        }
                        prev = ptr;
                        ptr = c &lt; 0 ? ptr.left : ptr.right;
                }
                BSTNode<t> tmp = new BSTNode<t>(target);
                size++;
                if (root == null) {
                        root = tmp;
                        return;
                }
                if (c &lt; 0) {
                        prev.left = tmp;
                } else {
                        prev.right = tmp;
                }
        }
</t></t></t></pre>
Write a recursive version of this method, using a helper method if necessary.
<p>
<b>SOLUTION</b>
</p><pre>
   public class BSTN&lt;T extends Comparable&lt;T&gt;&gt; {
      ...
        public void insert(T target) 
        throws IllegalArgumentException {
                root = insert(target, root);
                size++;
        }

        private BSTNode&lt;T&gt; insert(T target, BST&lt;T&gt; root) 
        throws IllegalArgumentException {
               
                if (root == null) {
                        return new BSTNode<t>(target);
                }

                int c = target.compareTo(root.data);
                if (c == 0) {
                        throw new IllegalArgumentException("Duplicate key");
                }
                if (c &lt; 0) {
                        root.left = insert(target, root.left);
                } else {
                        root.right = insert(target, root.right);
                }
                return root;
        }

</t></pre>

<hr>
</li><li><span class="star">*</span> 
With the same <b>BSTNode</b> class as in the previous problem,
write a method to count all entries in the tree whose keys
are in a given range of values. Your implementation should make as few
data comparisons as possible.
<pre>     
    // Accumulates, in a given array list, all entries in a BST whose keys are in a given range,
    // including both ends of the range - i.e. all entries x such that min &lt;= x &lt;= max. 
    // The accumulation array list, result, will be filled with node data entries that make the cut. 
    // The array list is already created (initially empty) when this method is first called.
    public static &lt;T extends Comparable&lt;T&gt;&gt; 
    void keysInRange(BSTNode&lt;T&gt; root, T min, T max, ArrayList&lt;T&gt; result) {
        /* COMPLETE THIS METHOD */

     }
</pre>

<p>
<b>SOLUTION</b>
</p><pre>    public static &lt;T extends Comparable&lt;T&gt;&gt; 
    void keysInRange(BSTNode&lt;T&gt; root, T min, T max, ArrayList&lt;T&gt; result) {
        if (root == null) { 
           return;
        }
        int c1 = min.compareTo(root.data);
        int c2 = root.data.compareTo(max);
        if (c1 &lt;= 0 &amp;&amp; c2 &lt;= 0) {  // min &lt;= root &lt;= max) 
           result.add(root.data);
        }
        if (c1 &lt; 0) {
           keysInRange(root.left, min, max, result);
        }
        if (c2 &lt; 0) {
           keysInRange(root.right, min, max, result);
        }
    }

</pre>
<hr>
<li>With the same <b>BSTNode</b> class as in the previous problem,
write a method that would take
a BST with keys arranged in ascending order, and "reverse" it so all the keys are 
in descending order. For example:
<pre>                25                         25
              /    \                     /    \
            10     40      ---&gt;        40      10
           /  \   /  \                /  \    /  \
          2   20 30   45             45  30  20   2
             /    \                     /     \
            15    35                   35     15
</pre>
The modification is done in the input tree itself, NO new tree is created.
<pre>    public static &lt;T extends Comparable&lt;T&gt;&gt; 
    void reverseKeys(BSTNode&lt;T&gt; root) {
        /* COMPLETE THIS METHOD */

</pre>

<p>
<b>SOLUTION</b>
</p><pre>    public static &lt;T extends Comparable&lt;T&gt;&gt; 
    void reverseKeys(BSTNode&lt;T&gt; root) {
       if (root == null) { 
          return;
       }
       reverseKeys(root.left);
       reverseKeys(root.right);
       BSTNode&lt;T&gt; ptr = root.left;
       root.left = root.right;
       root.right = ptr;
    }
</pre>
<p><hr>
<li><span class="star">*</span> A binary search tree may be modified as follows: in every node,
store the number of nodes in its <em>right subtree</em>. This modification
is useful to answer the question: what is the <b>k-th largest element</b> in the
binary search tree? (k=1 refers to the largest element, k=2 refers to
the second largest element, etc.)
<p>You are given the following enhanced binary search tree node implementation:</p>
<pre>   
    public class BSTNode&lt;T extends Comparable&lt;T&gt;&gt; {
       T data;
       BSTNode&lt;T&gt; left, right;
       int rightSize;  // number of entries in right subtree 
       ...
    }

</pre>
Implement the following <em>recursive</em> method to find the <b>k-th largest</b>
entry in a BST:
<pre>   
    public static &lt;T extends Comparable&lt;T&gt;&gt; T kthLargest(BSTNode&lt;T&gt; root, int k) {
       /* COMPLETE THIS METHOD */
    }

</pre>
<p>
<b>SOLUTION</b>
Assume root is not null, and <em>1</em> &lt;= <em>k</em> &lt; <em>n</em>
</p><pre>    public static &lt;T extends Comparable&lt;T&gt;&gt; 
    T kthLargest(BSTNode&lt;T&gt; root, int k) {
       if (root.rightSize == (k-1)) {
           return root.data;
       }
       if (root.rightSize &gt;= k) {
           return kthLargest(root.right, k);
       }
       return kthLargest(root.left, k-root.rightSize-1);
    }

</pre>
</ol>


</body></html>
